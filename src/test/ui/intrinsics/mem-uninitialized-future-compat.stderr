error: the type `T` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:13:5
   |
LL |     std::mem::uninitialized::<T>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: type might not be allowed to be left uninitialized

error: the type `[T; N]` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:16:5
   |
LL |     std::mem::uninitialized::<[T; N]>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: type might not be allowed to be left uninitialized

error: the type `[char; N]` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:19:5
   |
LL |     std::mem::uninitialized::<[char; N]>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: characters must be a valid Unicode codepoint

error: the type `[UninitStruct; N]` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:22:5
   |
LL |     std::mem::uninitialized::<[UninitStruct; N]>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this struct field)
  --> $DIR/mem-uninitialized-future-compat.rs:9:5
   |
LL |     b: char,
   |     ^^^^^^^

error: the type `&u32` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:31:9
   |
LL |         std::mem::uninitialized::<&'static u32>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: references must be non-null

error: the type `std::boxed::Box<u32>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:34:9
   |
LL |         std::mem::uninitialized::<Box<u32>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: `Box` must be non-null

error: the type `fn()` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:37:9
   |
LL |         std::mem::uninitialized::<fn()>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: function pointers must be non-null

error: the type `!` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:40:9
   |
LL |         std::mem::uninitialized::<!>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: the `!` type has no valid value

error: the type `*mut dyn std::io::Write` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:43:9
   |
LL |         std::mem::uninitialized::<*mut dyn std::io::Write>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: the vtable of a wide raw pointer must be non-null

error: the type `bool` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:46:9
   |
LL |         std::mem::uninitialized::<bool>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: booleans must be either `true` or `false`

error: the type `char` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:49:9
   |
LL |         std::mem::uninitialized::<char>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: characters must be a valid Unicode codepoint

error: the type `UninitStruct` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:52:9
   |
LL |         std::mem::uninitialized::<UninitStruct>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this struct field)
  --> $DIR/mem-uninitialized-future-compat.rs:9:5
   |
LL |     b: char,
   |     ^^^^^^^

error: the type `[UninitStruct; 16]` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:55:9
   |
LL |         std::mem::uninitialized::<[UninitStruct; 16]>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this struct field)
  --> $DIR/mem-uninitialized-future-compat.rs:9:5
   |
LL |     b: char,
   |     ^^^^^^^

error: the type `(u32, char)` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:58:9
   |
LL |         std::mem::uninitialized::<(u32, char)>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: characters must be a valid Unicode codepoint

error: aborting due to 14 previous errors

Future incompatibility report: Future breakage diagnostic:
error: the type `T` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:13:5
   |
LL |     std::mem::uninitialized::<T>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: type might not be allowed to be left uninitialized

Future breakage diagnostic:
error: the type `[T; N]` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:16:5
   |
LL |     std::mem::uninitialized::<[T; N]>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: type might not be allowed to be left uninitialized

Future breakage diagnostic:
error: the type `[char; N]` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:19:5
   |
LL |     std::mem::uninitialized::<[char; N]>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: characters must be a valid Unicode codepoint

Future breakage diagnostic:
error: the type `[UninitStruct; N]` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:22:5
   |
LL |     std::mem::uninitialized::<[UninitStruct; N]>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this struct field)
  --> $DIR/mem-uninitialized-future-compat.rs:9:5
   |
LL |     b: char,
   |     ^^^^^^^

Future breakage diagnostic:
error: the type `&u32` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:31:9
   |
LL |         std::mem::uninitialized::<&'static u32>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: references must be non-null

Future breakage diagnostic:
error: the type `std::boxed::Box<u32>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:34:9
   |
LL |         std::mem::uninitialized::<Box<u32>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: `Box` must be non-null

Future breakage diagnostic:
error: the type `fn()` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:37:9
   |
LL |         std::mem::uninitialized::<fn()>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: function pointers must be non-null

Future breakage diagnostic:
error: the type `!` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:40:9
   |
LL |         std::mem::uninitialized::<!>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: the `!` type has no valid value

Future breakage diagnostic:
error: the type `*mut dyn std::io::Write` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:43:9
   |
LL |         std::mem::uninitialized::<*mut dyn std::io::Write>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: the vtable of a wide raw pointer must be non-null

Future breakage diagnostic:
error: the type `bool` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:46:9
   |
LL |         std::mem::uninitialized::<bool>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: booleans must be either `true` or `false`

Future breakage diagnostic:
error: the type `char` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:49:9
   |
LL |         std::mem::uninitialized::<char>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: characters must be a valid Unicode codepoint

Future breakage diagnostic:
error: the type `UninitStruct` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:52:9
   |
LL |         std::mem::uninitialized::<UninitStruct>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this struct field)
  --> $DIR/mem-uninitialized-future-compat.rs:9:5
   |
LL |     b: char,
   |     ^^^^^^^

Future breakage diagnostic:
error: the type `[UninitStruct; 16]` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:55:9
   |
LL |         std::mem::uninitialized::<[UninitStruct; 16]>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this struct field)
  --> $DIR/mem-uninitialized-future-compat.rs:9:5
   |
LL |     b: char,
   |     ^^^^^^^

Future breakage diagnostic:
error: the type `(u32, char)` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:58:9
   |
LL |         std::mem::uninitialized::<(u32, char)>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: characters must be a valid Unicode codepoint

