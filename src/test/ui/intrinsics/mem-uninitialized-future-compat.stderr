error: the type `T` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:26:5
   |
LL |     std::mem::uninitialized::<T>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: type might not be allowed to be left uninitialized

error: the type `[T; N]` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:29:5
   |
LL |     std::mem::uninitialized::<[T; N]>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: type might not be allowed to be left uninitialized

error: the type `[char; N]` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:32:5
   |
LL |     std::mem::uninitialized::<[char; N]>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: characters must be a valid Unicode codepoint

error: the type `[UninitStruct; N]` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:35:5
   |
LL |     std::mem::uninitialized::<[UninitStruct; N]>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this struct field)
  --> $DIR/mem-uninitialized-future-compat.rs:9:5
   |
LL |     b: char,
   |     ^^^^^^^

error: the type `std::result::Result<T, !>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:38:5
   |
LL |     std::mem::uninitialized::<Result<T, !>>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: enums have to be initialized to a variant
  --> $SRC_DIR/core/src/result.rs:LL:COL
   |
LL | pub enum Result<T, E> {
   | ^^^^^^^^^^^^^^^^^^^^^

error: the type `OneVariantWith<T>` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:41:5
   |
LL |     std::mem::uninitialized::<OneVariantWith<T>>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: type might not be allowed to be left uninitialized (in this enum field)
  --> $DIR/mem-uninitialized-future-compat.rs:22:11
   |
LL |     Hello(T),
   |           ^

error: the type `&u32` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:50:9
   |
LL |         std::mem::uninitialized::<&'static u32>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: references must be non-null

error: the type `std::boxed::Box<u32>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:53:9
   |
LL |         std::mem::uninitialized::<Box<u32>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: `Box` must be non-null

error: the type `fn()` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:56:9
   |
LL |         std::mem::uninitialized::<fn()>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: function pointers must be non-null

error: the type `!` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:59:9
   |
LL |         std::mem::uninitialized::<!>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: the `!` type has no valid value

error: the type `*mut dyn std::io::Write` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:62:9
   |
LL |         std::mem::uninitialized::<*mut dyn std::io::Write>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: the vtable of a wide raw pointer must be non-null

error: the type `bool` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:65:9
   |
LL |         std::mem::uninitialized::<bool>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: booleans must be either `true` or `false`

error: the type `char` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:68:9
   |
LL |         std::mem::uninitialized::<char>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: characters must be a valid Unicode codepoint

error: the type `UninitStruct` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:71:9
   |
LL |         std::mem::uninitialized::<UninitStruct>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this struct field)
  --> $DIR/mem-uninitialized-future-compat.rs:9:5
   |
LL |     b: char,
   |     ^^^^^^^

error: the type `[UninitStruct; 16]` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:74:9
   |
LL |         std::mem::uninitialized::<[UninitStruct; 16]>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this struct field)
  --> $DIR/mem-uninitialized-future-compat.rs:9:5
   |
LL |     b: char,
   |     ^^^^^^^

error: the type `(u32, char)` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:77:9
   |
LL |         std::mem::uninitialized::<(u32, char)>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
   = note: characters must be a valid Unicode codepoint

error: the type `TwoVariant` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:80:9
   |
LL |         std::mem::uninitialized::<TwoVariant>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: enums have to be initialized to a variant
  --> $DIR/mem-uninitialized-future-compat.rs:16:1
   |
LL | enum TwoVariant {
   | ^^^^^^^^^^^^^^^

error: the type `std::result::Result<!, !>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:83:9
   |
LL |         std::mem::uninitialized::<Result<!, !>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: enums have to be initialized to a variant
  --> $SRC_DIR/core/src/result.rs:LL:COL
   |
LL | pub enum Result<T, E> {
   | ^^^^^^^^^^^^^^^^^^^^^

error: the type `std::result::Result<!, u32>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:86:9
   |
LL |         std::mem::uninitialized::<Result<!, u32>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: enums have to be initialized to a variant
  --> $SRC_DIR/core/src/result.rs:LL:COL
   |
LL | pub enum Result<T, E> {
   | ^^^^^^^^^^^^^^^^^^^^^

error: the type `std::option::Option<!>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:89:9
   |
LL |         std::mem::uninitialized::<Option<!>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: enums have to be initialized to a variant
  --> $SRC_DIR/core/src/option.rs:LL:COL
   |
LL | pub enum Option<T> {
   | ^^^^^^^^^^^^^^^^^^

error: the type `OneVariantWith<char>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:92:9
   |
LL |         std::mem::uninitialized::<OneVariantWith<char>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this enum field)
  --> $DIR/mem-uninitialized-future-compat.rs:22:11
   |
LL |     Hello(T),
   |           ^

error: the type `OneVariantWith<!>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:95:9
   |
LL |         std::mem::uninitialized::<OneVariantWith<!>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
   = note: for more information, see FIXME: fill this in
note: the `!` type has no valid value (in this enum field)
  --> $DIR/mem-uninitialized-future-compat.rs:22:11
   |
LL |     Hello(T),
   |           ^

error: aborting due to 22 previous errors

Future incompatibility report: Future breakage diagnostic:
error: the type `T` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:26:5
   |
LL |     std::mem::uninitialized::<T>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: type might not be allowed to be left uninitialized

Future breakage diagnostic:
error: the type `[T; N]` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:29:5
   |
LL |     std::mem::uninitialized::<[T; N]>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: type might not be allowed to be left uninitialized

Future breakage diagnostic:
error: the type `[char; N]` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:32:5
   |
LL |     std::mem::uninitialized::<[char; N]>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: characters must be a valid Unicode codepoint

Future breakage diagnostic:
error: the type `[UninitStruct; N]` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:35:5
   |
LL |     std::mem::uninitialized::<[UninitStruct; N]>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this struct field)
  --> $DIR/mem-uninitialized-future-compat.rs:9:5
   |
LL |     b: char,
   |     ^^^^^^^

Future breakage diagnostic:
error: the type `std::result::Result<T, !>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:38:5
   |
LL |     std::mem::uninitialized::<Result<T, !>>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: enums have to be initialized to a variant
  --> $SRC_DIR/core/src/result.rs:LL:COL
   |
LL | pub enum Result<T, E> {
   | ^^^^^^^^^^^^^^^^^^^^^

Future breakage diagnostic:
error: the type `OneVariantWith<T>` is generic, and might not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:41:5
   |
LL |     std::mem::uninitialized::<OneVariantWith<T>>();
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     this code causes undefined behavior when executed
   |     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: type might not be allowed to be left uninitialized (in this enum field)
  --> $DIR/mem-uninitialized-future-compat.rs:22:11
   |
LL |     Hello(T),
   |           ^

Future breakage diagnostic:
error: the type `&u32` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:50:9
   |
LL |         std::mem::uninitialized::<&'static u32>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: references must be non-null

Future breakage diagnostic:
error: the type `std::boxed::Box<u32>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:53:9
   |
LL |         std::mem::uninitialized::<Box<u32>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: `Box` must be non-null

Future breakage diagnostic:
error: the type `fn()` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:56:9
   |
LL |         std::mem::uninitialized::<fn()>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: function pointers must be non-null

Future breakage diagnostic:
error: the type `!` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:59:9
   |
LL |         std::mem::uninitialized::<!>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: the `!` type has no valid value

Future breakage diagnostic:
error: the type `*mut dyn std::io::Write` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:62:9
   |
LL |         std::mem::uninitialized::<*mut dyn std::io::Write>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: the vtable of a wide raw pointer must be non-null

Future breakage diagnostic:
error: the type `bool` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:65:9
   |
LL |         std::mem::uninitialized::<bool>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: booleans must be either `true` or `false`

Future breakage diagnostic:
error: the type `char` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:68:9
   |
LL |         std::mem::uninitialized::<char>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: characters must be a valid Unicode codepoint

Future breakage diagnostic:
error: the type `UninitStruct` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:71:9
   |
LL |         std::mem::uninitialized::<UninitStruct>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this struct field)
  --> $DIR/mem-uninitialized-future-compat.rs:9:5
   |
LL |     b: char,
   |     ^^^^^^^

Future breakage diagnostic:
error: the type `[UninitStruct; 16]` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:74:9
   |
LL |         std::mem::uninitialized::<[UninitStruct; 16]>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this struct field)
  --> $DIR/mem-uninitialized-future-compat.rs:9:5
   |
LL |     b: char,
   |     ^^^^^^^

Future breakage diagnostic:
error: the type `(u32, char)` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:77:9
   |
LL |         std::mem::uninitialized::<(u32, char)>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
   = note: characters must be a valid Unicode codepoint

Future breakage diagnostic:
error: the type `TwoVariant` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:80:9
   |
LL |         std::mem::uninitialized::<TwoVariant>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: enums have to be initialized to a variant
  --> $DIR/mem-uninitialized-future-compat.rs:16:1
   |
LL | enum TwoVariant {
   | ^^^^^^^^^^^^^^^

Future breakage diagnostic:
error: the type `std::result::Result<!, !>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:83:9
   |
LL |         std::mem::uninitialized::<Result<!, !>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: enums have to be initialized to a variant
  --> $SRC_DIR/core/src/result.rs:LL:COL
   |
LL | pub enum Result<T, E> {
   | ^^^^^^^^^^^^^^^^^^^^^

Future breakage diagnostic:
error: the type `std::result::Result<!, u32>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:86:9
   |
LL |         std::mem::uninitialized::<Result<!, u32>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: enums have to be initialized to a variant
  --> $SRC_DIR/core/src/result.rs:LL:COL
   |
LL | pub enum Result<T, E> {
   | ^^^^^^^^^^^^^^^^^^^^^

Future breakage diagnostic:
error: the type `std::option::Option<!>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:89:9
   |
LL |         std::mem::uninitialized::<Option<!>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: enums have to be initialized to a variant
  --> $SRC_DIR/core/src/option.rs:LL:COL
   |
LL | pub enum Option<T> {
   | ^^^^^^^^^^^^^^^^^^

Future breakage diagnostic:
error: the type `OneVariantWith<char>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:92:9
   |
LL |         std::mem::uninitialized::<OneVariantWith<char>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: characters must be a valid Unicode codepoint (in this enum field)
  --> $DIR/mem-uninitialized-future-compat.rs:22:11
   |
LL |     Hello(T),
   |           ^

Future breakage diagnostic:
error: the type `OneVariantWith<!>` does not permit being left uninitialized
  --> $DIR/mem-uninitialized-future-compat.rs:95:9
   |
LL |         std::mem::uninitialized::<OneVariantWith<!>>();
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |         |
   |         this code causes undefined behavior when executed
   |         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done
   |
note: the lint level is defined here
  --> $DIR/mem-uninitialized-future-compat.rs:2:9
   |
LL | #![deny(mem_uninitialized)]
   |         ^^^^^^^^^^^^^^^^^
   = note: for more information, see FIXME: fill this in
note: the `!` type has no valid value (in this enum field)
  --> $DIR/mem-uninitialized-future-compat.rs:22:11
   |
LL |     Hello(T),
   |           ^

